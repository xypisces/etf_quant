## Context

当前 ETF 全量动量排名页面（`app/pages/2_Pool_Manager.py`）实现了以下功能：
- 从 `ETFCatalog` 加载全量 A 股 ETF 列表（约 900+ 只）
- 用户点击按钮后，逐一对所有 ETF 进行增量数据更新 + 动量计算
- 计算完成后以表格形式展示排名结果
- 每次计算结果仅存在于当前会话，无持久化

存储层使用 `DataStorage`（SQLite 元数据 + Parquet 行情数据），ETF 目录使用 `ETFCatalog`（Parquet 缓存）。

## Goals / Non-Goals

**Goals:**
- 支持用户通过下拉多选框筛选特定 ETF 标的进行动量计算
- 将最近一次排名结果持久化到本地，页面加载时自动展示
- 提供"重新计算 Top50"快捷按钮，基于缓存结果快速重算

**Non-Goals:**
- 不改动动量计算算法本身（仍沿用收盘价涨幅法）
- 不引入定时自动计算或后台任务
- 不修改 `DataStorage` 或 `ETFCatalog` 模块

## Decisions

### 1. 排名结果持久化方案：独立 Parquet 文件

**选择**：在 `data/` 目录下使用独立 Parquet 文件存储排名结果（`data/momentum_ranking_cache.parquet`）。

**理由**：
- 排名结果是扁平表格数据，Parquet 格式与项目已有的存储方式一致
- 与 `DataStorage` 模块保持独立，避免引入不必要的耦合
- 文件读写简单直接，Streamlit 页面加载时用 `pd.read_parquet()` 即可

**备选方案**：
- SQLite 存储：过重，排名结果结构简单无需关系型存储
- JSON 文件：不利于大量行数据的高效读取

### 2. 缓存元数据：在 Parquet 文件中内嵌元信息

**选择**：将排名参数（计算时间、动量周期、标的范围类型）作为额外列保存在同一 Parquet 文件中。

**理由**：
- 避免引入额外的元数据文件
- 页面加载时一次读取即可获得所有上下文信息

### 3. 筛选组件：Streamlit `st.multiselect`

**选择**：使用 `st.multiselect` 实现 ETF 筛选，选项来自 `ETFCatalog`，格式为 `{code} - {name}`。

**理由**：
- Streamlit 原生组件，支持搜索和多选
- 无需引入第三方 UI 库
- 用户可搜索代码或名称快速定位

### 4. "重新计算 Top50"逻辑：从缓存中读取标的列表

**选择**：读取缓存文件的前 50 名标的代码，仅对这些标的执行增量更新 + 动量重算。

**理由**：
- 将约 900+ 只标的的全量计算缩减到 50 只，大幅提升速度
- 复用现有的计算流程，仅改变输入标的集合

### 5. 全量 vs 筛选缓存策略

**选择**：
- 全量计算：仅保存前 50 名到缓存
- 筛选计算：保存全部筛选结果到缓存

**理由**：
- 全量排名后 50 名之后的标的价值较低，无需占用存储
- 筛选场景中用户选择的标的本身就是有限集合，全部保存

## Risks / Trade-offs

- **缓存覆盖问题**：每次新计算会覆盖上次缓存结果，只保留最近一次排名。
  → 缓解：这是预期行为，符合用户需求"保留最近一次结果"。
- **筛选状态不持久**：下拉框选择不会跨会话保存，用户重新打开页面时默认全量。
  → 缓解：当前需求不要求持久化筛选条件，后续可扩展。
- **Parquet 文件并发读写**：Streamlit 多用户场景下可能存在竞争。
  → 缓解：当前为单用户本地部署，暂不影响。
